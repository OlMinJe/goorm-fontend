> Day01부터 Day03까지의 학습 일지

# 📘 React란 무엇인가?

## 등장 배경(2013, Meta 내부 → 오픈소스)

- 복잡한 UI에서 성능/유지보수 이슈 해결을 목표로 탄생!
- DOM 조작을 추상화하고 **상태 중심 선언형 UI** 채택

## React의 철학

- UI는 곧 `state`, 상태가 바뀌면 UI를 다시 그려서 일관성을 유지한다.
- 명령형("어떻게 바꿀지") → 선언형("무엇을 보여줄지")

## 주요 원칙

| 원칙               | 설명                                                                          |
| ------------------ | ----------------------------------------------------------------------------- |
| 선언형 UI          | **결과**만 선언하면 React가 DOM 갱신을 맡는다.                                |
| 컴포넌트 기반      | 작게 쪼개서 재사용하며, 각각 독립적인 상태/로직을 보유한다.                   |
| 단방향 데이터 흐름 | 데이터는 부모 → 자식(`props`), 이벤트는 자식 → 부모(콜백)의 흐름을 갖는다.    |
| Virtual Dom        | 이전 트리와 새 트리를 비교하여 `diff` 즉, 바뀐 곳만 실제 DOM 패치를 진행한다. |
| 불변성 지향        | 상태를 **교체**하여 변경 감지 및 최적화가 쉬워졌다.                           |

# 📘 React 들어가기

> CRA는 이제 비추천! Vite로 시작하자!

## 설치

```bash
npm create vite@latest goorm-project -- --template react
cd goorm-project
npm i
npm run dev
```

## 폴더 구조

```bash
goorm-project/
├─ index.html            # root div (마운트 포인트)
├─ package.json          # 스크립트/의존성
├─ vite.config.(js|ts)   # Vite 설정
└─ src/
   ├─ main.(jsx|tsx)     # 진입점 (createRoot)
   ├─ App.(jsx|tsx)      # 최상위 컴포넌트
   └─ assets/            # 정적 리소스
```

## 핵심 파일

### 1. `index.html`

```html
<div id="root"></div>
<script type="module" src="/src/main.jsx"></script>
```

#### ⭐️ `root`가 핵심인 이유

`<div id="root">`는 브라우저가 처음 읽는 정적 HTML 안에 React가 통째로 **접수**할 구역이다.

| 장점           | 내용                                                                                                                             |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| 명확한 경계    | `#root` 내부는 React가 렌더/패치/정리까지 전권을 행사하며, 외부 스크립트가 같은 DOM을 만지면 일관성이 깨진다.                    |
| 상태 보존      | React는 자신의 트리(가상 DOM ↔ 실제 DOM)를 가정하고 diff를 수행하여, 경계가 깨지면 상태/포커스/애니메이션 같은 게 쉽게 망가진다. |
| 여러 루트 가능 | 필요하면 페이지 곳곳에 `#modal-root`, `#widget-root`처럼 다중 루트를 돌 수 있다. (위젯 삽입 등)                                  |

외부 라이브러리를 써야 한다면 `ref` + `effect` 패턴으로 “React가 알고 있게” 연결해야 한다고 한다.

#### ⭐️ `<script type="module" src="/src/main.jsx">`가 핵심인 이유 — “진입점과 모듈 그래프”

- 이 스크립트가 앱의 시작 버튼으로, 여기서 React를 불러오고, 루트를 만들고, App을 렌더한다.
- ESM(모듈) 장점
  1. 정적 `import` 덕분에 번들러(Vite)가 의존성 그래프를 만들고 코드 분할/트리 셰이킹/HMR을 정확히 수행.
     > `import ... from '...'`처럼 코드를 실행하기 전부터(빌드 시점) 무엇을 가져오는지 다 드러나는 방식이라, 빌드 도구(Vite)가 전체 의존성 지도를 만들고, 안 쓰는 코드 제거(트리 셰이킹), 필요한 덩어리만 쪼개서 내려보내기(코드 분할), `파일 바꿔도 새로고침 없이 갈아끼우기(HMR)`를 안정적으로 해줄 수 있다는 의미이다.
     >
     > #### 의존성 지도란?
     >
     > 비유하자면 "요리 재료 목록"이다.<br/>
     > 파일들이 서로 `import`로 연결되어 있는데, Vite는 그걸 한눈에 보는 장바구니 목록으로 만든다고 생각할 수 있다.(천재)
     >
     > #### 트리 셰이킹이란?
     >
     > "짐 챙길 때 안 입는 옷 빼기"에 비유할 수 있다.<br/>
     > 파일에서 `export`를 했는데 아무도 `import` 하지 않는 함수 및 변수가 있으면, Vite가 "어라 안쓰네?"하고 최종 번들에서 제거한다.
     >
     > #### 코드 분할
     >
     > 처음 페이지 들어올 때 모든 화면의 코드를 한 번에 다 받으면 무겁기 때문에, 지금 필요한 것만 먼저 보내고, 다른 페이지로 갈 때 그때그때 추가로 가져오도록 나눠 놓은 걸 의미한다.
     >
     > #### HMR
     >
     > 바뀐 파일만 쏙 빼서 갈아끼우는 기술로, 화면 상태(ex. 입력값, 스크롤 등)를 유지한 채로 UI만 업데이트 된다.
  2. `<script type="module">`는 브라우저가 자동 `defer`로 처리해서 HTML 파싱을 막지 않는다. 덕분에 `#root`가 먼저 만들어지고, 그다음 `main.jsx`가 실행되어 안전하게 마운트된다.
     > `<script type="module">` 자동 `defer`<br/>
     > 모듈 스크립트는 브라우저가 HTML 파싱을 먼저 끝내고 실행한다. 그래서 `index.html`의 `#root`가 이미 만들어진 뒤 `main.jsx`가 실행되어 안전하게 React를 마운트할 수 있다는 뜻이다.

### 2.`main.jsx`

```jsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.jsx';
import './index.css';

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

- `StrictMode`: 개발 중 잠재 문제를 탐지하는 빡센 검사 버전
- 동시성 렌더링 아키텍처를 활용하는 `createRoot`

#### ⭐️ `createRoot(...)`가 핵심인 이유 — “React 18+의 동시성 렌더링 아키텍처”

1. 동시성 렌더링(Concurrent Rendering) 기반
   - React가 렌더 작업을 `쪼개고, 일시 정지했다가, 재개`할 수 있다.
   - 큰 업데이트 동안에도 `사용자 입력/애니메이션`의 반응성이 유지된다.
2. 자동 배칭(Automatic Batching)
   - 여러 `setState`를 한 프레임에 모아 `렌더 1번`으로 처리 → 불필요한 리렌더 감소.
3. 전환(Transitions)
   - `startTransition`, `useTransition`으로 덜 급한 업데이트를 느긋한 우선순위로 처리 → 입력/스크롤이 끊기지 않음.
4. 서스펜스/스트리밍 SSR과 찰떡
   - 데이터/리소스 로딩을 컴포넌트 단위로 기다렸다가 점진적으로 표시.

#### ⭐️ `<StrictMode>`가 핵심인 이유 — “개발 중 버그를 조기 탐지”

- 프로덕션(배포본)에는 영향 없음. 개발 중에만 동작.
- 일부 코드를 일부러 두 번 돌려서 “정리 안 한 부작용, 레거시 사용, 흔한 실수”를 빨리 발견하게 해줌.

> **그러면 무엇을 잡아주는가?**<br/>
>
> - 특정 생명주기/훅을 의도적으로 2회 실행(마운트→언마운트→다시 마운트)하여 순수하지 않은 코드(idempotent 아님), 누수, 정리 누락을 드러낸디.
> - `findDOMNode`, 문자열 ref 등 옛날 방식을 사용하면 경고를 띄워준다.

초반에 “조금 시끄럽더라도” 문제를 드러내야, 나중에 규모가 커졌을 때 `디버깅 지옥`을 피한다.

### 3. `App.jsx`

```jsx
import { useState } from 'react';
import './App.css';

export default function App() {
  const [count, setCount] = useState(0);
  return (
    <>
      <h1>Vite + React</h1>
      <button onClick={() => setCount((c) => c + 1)}>count is {count}</button>
    </>
  );
}
```

# 📘 모듈 시스템(`import`/`export`)

- `default export`: 파일 대표 기능을 딱 한 번만 가져온다.
- `named export`: 여러 개 기능을 동일 이름으로 가져온다.
- 배럴 파일(`index.js`)로 묶어서 가져오면 편하다!

  > **배럴 파일(index.js)로 묶어 가져오기**란<br/>
  > 폴더 안의 여러 파일에서 내보낸 것들을 한 군데(`index`)에서 재수출(re-export)해서, 한 줄 `import`로 편하게 가져오게 만드는 패턴을 의미한다.
  >
  > ### 이게 왜 편한가요?
  >
  > 1. `import 경로 단축`: `../components/Button`, `../components/Card` … 여러 줄을 `../components` 한 줄로 표현할 수 있다.
  > 2. `공개 API 정리`: “이 폴더에서 외부로 무엇을 쓸 수 있는지”를 `index.js` 한 파일에서 명확히 관리
  > 3. `리팩터 쉬움`: 파일 위치가 바뀌어도 `index.js`만 고치면, 바깥 코드는 그대로

## 어떻게 쓰나요?

> 배럴 파일은 폴더의 공식 출입문으로, 폴더 안 exports를 **index.js에서 한 번에 재수출**해서, **경로 단축 + 사용 범위 명확화 등**을 얻는 패턴

```jsx
// utils/index.js
export { default as add } from './add.js';
export { multiply } from './multiply.js';

// app.js
import { add, multiply } from './utils';
```

### (1) 배럴 파일 없이

```jsx
// App.jsx
import Button from './components/Button.jsx';
import Card from './components/Card.jsx';
import { useToggle } from './components/hooks/useToggle.js';
```

### (2) 배럴 파일로 묶기

```bash
components/
├─ Button.jsx
├─ Card.jsx
├─ hooks/
│  └─ useToggle.js
└─ index.js   // ← 배럴 파일
```

```jsx
// components/index.js  (재수출 전용, 로직 넣지 않기)
export { default as Button } from './Button.jsx';
export { default as Card } from './Card.jsx';
export { useToggle } from './hooks/useToggle.js';
```

```jsx
// App.jsx
import { Button, Card, useToggle } from './components';
```

> 경로가 폴더까지만 가고, 필요한 것들을 중괄호 한 번에 꺼내 쓸 수 있다.

---

## React에서 자주 쓰는 예시

```bash
components/
  Header.jsx        (default export)
  Footer.jsx        (named export)
  index.js
```

```jsx
// components/index.js
export { default as Header } from './Header.jsx';
export { Footer } from './Footer.jsx';
```

```jsx
// App.jsx
import { Header, Footer } from '@/components'; // 경로 별칭(예: Vite/tsconfig) 쓰면 더 깔끔
```

## 주의할 점

1. `재수출 전용`으로만 사용하기
   - 배럴은 모아 두는 출입문일 뿐이라, 여기서 무언가를 실행하면(콘솔 로그, 전역 등록 등) 예측이 어려워진다.
2. 순환 의존성 조심 (A↔B서로 import)
   - `a/index.js`가 `b/index.js`를, `b/index.js`가 다시 `a/index.js`를 불러오면 초기화 순서 꼬인다.(`undefined` 혹은 이상한 버그가 나올 수도?)
3. 트리 셰이킹(="안 쓰는 건 빼서 가볍게") 잘 되게 `정적 재수출` 사용하기
   - 번틀러가 사용해야 할 코드를 구분하고 안 쓰는 코드를 제거할 수 있다.
4. Typescript라면 `export type`을 사용해야 한다.
   - 타입만 내보낼 때는 런터임 코드가 안 생기게, `export type { Foo } from './Foo'`로 내보내야 한다.

# 📘 JSX 들어가며

- JS 안에서 HTML 같은 문법으로, Babel이 `React.createElement`로 변환해준다.

## 규칙

1. 하나의 부모로 감싸기
2. JS 표현식은 `{}` 내부
3. DOM 속성은 camelCase(`className`, `onClick`)
4. 조건부 및 반복 랜더링 자연스럽게
   > JSX 안에서 그냥 자바스크립트 표현식을 {}로 바로 넣을 수 있어서, **조건문(조건부 렌더링)**이나 **반복문(리스트 렌더링)**을 “템플릿 문법” 없이 자연스럽게 쓸 수 있다는 뜻이다.

# 📘 Hooks 요약

| 종류    | 설명                                                                                |
| ------- | ----------------------------------------------------------------------------------- |
| State   | `useState`, `useReducer`                                                            |
| Context | `useContext`                                                                        |
| Ref     | `useRef`, `useImperativeHandle`                                                     |
| Effect  | `useEffect`, `useLayoutEffect`, `useInsertionEffect`                                |
| 성능    | `useMemo`, `useCallback`, `useTransition`, `useDeferredValue`                       |
| 기타    | `useId`, `useSyncExternalStore`, `useDebugValue`, `useActionState`, `useOptimistic` |

# 📘 컴포넌트와 Props

- 컴포넌트란, 재사용 가능한 UI 블록
- Props란, 부모에서 자식으로 내려보내는 읽기 전용 데이터

```jsx
// User.jsx
function User({ name, age }) {
  return (
    <div className="p-4 rounded-xl border">
      <h2>{name}님, 환영합니다! 🎉</h2>
      <p>나이: {age}</p>
    </div>
  );
}

// App.jsx
export default function App() {
  return <User name="시온" age={28} />;
}
```

## 1) 컴포넌트

> UI를 함수로 정의한다.

1. 분할·재사용
   - 큰 화면을 버튼/카드/섹션처럼 `작은 조각`으로 쪼갤 수 있다.
   - 각 조각은 독립적인 파일/함수로, 테스트/교체/이식이 쉬움.
2. 선언형
   - “이 상태면 이렇게 보여줘”만 적는다.
   - DOM을 직접 건드리지 않아도 React가 `업데이트를 대신` 해주는 큰 강점!

```jsx
// User.jsx
function User({ name, age }) {
  return (
    <div className="p-4 rounded-xl border">
      <h2>{name}님, 환영합니다! 🎉</h2>
      <p>나이: {age}</p>
    </div>
  );
}
```

## 2) Props

> 부모가 자식에게 건네는 읽기 전용 데이터

- `단방향 데이터 흐름(부모→자식)`의 중심으로, 화면 전체 동작이 예측 가능
- 같은 컴포넌트를 `다른 값`으로 쉽게 커스텀이 가능하여 재사용성 짱.
- 자식이 `props`를 절대 수정하지 않으니 데이터 이동 경로가 명확하다.[=불변(읽기 전용]

```jsx
// App.jsx
export default function App() {
  return <User name="시온" age={28} />; // 부모가 값을 "주입"
}
```

### 1.`Props`는 읽기 전용

불변성을 띄우며, 값을 바꾸려면 부모가 새로운 값을 내려줘야 한다.

### 2. `children`: “틀과 내용 분리(컴포지션)”

- 레이아웃(틀)과 콘텐츠(내용)를 분리해 재사용을 가능하게 해준다.

```jsx
function Card({ children }) {
  return <div className="p-4 rounded-xl shadow">{children}</div>;
}

export default function App() {
  return (
    <Card>
      <h3>오늘의 할 일</h3>
      <p>컴포넌트 복습 / useRef 연습</p>
    </Card>
  );
}
```

### 3. “슬롯”/“컴파운드 컴포넌트” 패턴

여러 영역(헤더/바디/푸터)을 명시적으로 나누고 싶은 경우에는 아래처럼 사용한다.

```jsx
function Card({ children }) { return <div className="card">{children}</div>; }
Card.Header = function Header({ children }) { return <header>{children}</header>; }
Card.Body   = function Body({ children })   { return <main>{children}</main>; }
Card.Footer = function Footer({ children }) { return <footer>{children}</footer>; }

// 사용
<Card>
  <Card.Header>제목</Card.Header>
  <Card.Body>본문</Card.Body>
  <Card.Footer>버튼들</Card.Footer>
</Card>
```

## 리렌더 기준

- 부모가 새로운 props(=새 참조) 를 자식으로 전달하면 자식은 리렌더된다.
- 특히 `인라인 객체/배열/함수`는 매 렌더마다 새로 만들어져서 참조가 달라진다.

이를 피하기 위해 아래와 같이 사용한다.

```jsx
const style = useMemo(() => ({ color: theme.color }), [theme.color]);
const onClick = useCallback(() => doSomething(id), [id]);

<Component style={style} onClick={onClick} />;
```

- `React.memo`: 같은 props면 렌더 스킵 (단, 과도한 사용은 메모리 사용 증가의 원인)

# 📘 이벤트

- HTML과 비슷하지만 camelCase로 작성하고 함수를 참조하여 넘긴다.(즉시 실행 X)<br/>`onClick={handleClick}`

```jsx
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  const increment = () => setCount((c) => c + 1);
  return <button onClick={increment}>Count: {count}</button>;
}
```

## 단방향 데이터 흐름: 올려 보내기

```jsx
// Child.jsx
export default function Child({ count, onIncrease }) {
  return (
    <div>
      <h2>자식: {count}</h2>
      <button onClick={onIncrease}>+1 증가</button>
    </div>
  )
}

// App.jsx
import { useState } from 'react'
import Child from './Child'

export default function App() {
  const [count, setCount] = useState(0)
  const increase = () => setCount((c) => c + 1) // 부모가 상태 보유
  return (
    <div>
      <h1>부모: {count}</h1>
      <Child count={count} onIncrease={increase} />
    </div>
  )
}
```

### `Child.jsx(자식)`

- `Child`는 상태가 없다. 대신 부모에게 받은 값(`count`)과 콜백(`onIncrease`)만 쓴다.
- 버튼을 누르면 `onIncrease` 함수 “참조” 자체를 React에게 넘긴다(즉시 호출 아님).

### `App.jsx(부모)`

- `count`는 오직 여기서만 관리한다.
- `increase`는 함수형 업데이트(`setCount(c => c + 1)`)를 사용한다.

### 클릭 후, 내부에서 벌어지는 일(흐름)

**데이터는 내려가고(props)**, **이벤트는 올라간다(callback)**

```
부모(App) ──(props: count, onIncrease)──▶ 자식(Child)
부모(App) ◀─(onIncrease() 호출: “증가해 주세요!”)── 자식(Child)

```

# 📘 `useRef` - 리렌더 없이 기억하기 + DOM 직접 참조

## 언제 사용하는가?

- 화면에 표시할 필요 없는 값(ex. `intervalId`, 이전 값 저장)
- DOM 노드 직접 제어(`focus`, `scrollIntoView`, `play` 등)

```jsx
import { useRef } from 'react';

export default function FocusDemo() {
  const inputRef = useRef(null);
  const focus = () => inputRef.current?.focus();

  return (
    <div>
      <input ref={inputRef} placeholder="이름을 입력하세요" />
      <button onClick={focus}>입력창 포커스</button>
    </div>
  );
}
```

## State vs Ref

```jsx
import { useState, useRef } from 'react';

export default function CounterPair() {
  const [count, setCount] = useState(0);
  const countRef = useRef(0);

  return (
    <>
      <button onClick={() => setCount((c) => c + 1)}>State Count: {count}</button>
      <button
        onClick={() => {
          countRef.current += 1; // 화면은 그대로, 값만 증가
          console.log('ref:', countRef.current);
        }}
      >
        Ref Count(콘솔 확인)
      </button>
    </>
  );
}
```

# 📘 React의 동작 흐름

1. `setState` 호출. 이때 변경 요청 큐에 비동기로 적재한다.
2. 새로운 Virtual DOM 생성
3. 이전과 새로운 Virtual DOM의 다른점 찾기(diffing)
4. 달라진 부분만 실제 DOM 패치를 진행한다.(Reconciliation)
5. 랜더 완료 후 `useEffect` 등 후처리를 실행한다.

# 📘 정리하며

| 개념               | 설명                                      |
| ------------------ | ----------------------------------------- |
| **JSX**            | JS에서 HTML 같은 문법. 가독성과 생산성↑   |
| **컴포넌트**       | UI 최소 단위(함수형 표준)                 |
| **Props**          | 부모→자식 읽기 전용 데이터                |
| **State**          | 컴포넌트 내부의 동적 데이터               |
| **Hook**           | 함수형에서 상태/생명주기/컨텍스트 등 사용 |
| **Context**        | 트리 깊어도 전역처럼 값 전달              |
| **Reconciliation** | Virtual DOM diff → 최소 DOM 업데이트      |
| **Keys**           | 리스트 항목 식별(성능/정확도 핵심)        |
