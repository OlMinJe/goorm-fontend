<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Object.create() 예제를 만들기</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }

      h2 {
        margin-top: 30px;
      }

      button {
        margin-top: 10px;
        padding: 8px 16px;
      }

      pre {
        background: #f4f4f4;
        padding: 10px;
        border-radius: 4px;
      }
    </style>
  </head>

  <body>
    <h1>Object.create()</h1>

    <!-- 1. 상속형 컴포넌트 -->
    <h2>상속형 컴포넌트</h2>
    <button onclick="component.render()">렌더링 하기</button>
    <pre id="output1"></pre>

    <!-- 2. 안전한 해시맵 -->
    <h2>안전한 해시맵 (Object.create(null))</h2>
    <input id="keyInput" placeholder="toString를 키로 입력" />
    <input id="valueInput" placeholder="값 입력" />
    <button onclick="addToSafeMap()">추가</button>
    <pre id="output2"></pre>

    <!-- 3. 읽기 전용 설정 -->
    <h2>읽기 전용 설정 객체</h2>
    <input id="appName" placeholder="앱 이름 수정" />
    <button onclick="tryToModify()">이름 바꾸기 시도</button>
    <p id="text"></p>
    <pre id="output3"></pre>
  </body>
  <script>
    /** ✅ Object.create()란?
     * 새로운 객체를 만들되, 그 객체의 프로토타입(부모)으로 proto를 설정해주는 함수이다.
     * 즉, 객체를 만들면서 누구한테 "상속"받을지를 지정할 수 있다.
     *
     * [형식]
     * const newObj = Object.create(부모객체);
     */

    // ========================= 1. 상속형 컴포넌트 =========================
    const BaseComponent = {
      mount() {
        return '✅ 컴포넌트 마운트 완료';
      },
    };

    // BaseComponent를 상속받은 객체로, component.mount()를 하면 자기 것처럼 BaseComponent안의 mount()를 사용할 수. ㅣㅆ음
    // const component = Object.create(BaseComponent);
    const component = Object.create(BaseComponent, {
      name: {
        value: 'MyComponent',
      },
      version: {
        value: '1.0.0',
      },
    });

    // component는 자신만의 메서드 render()를 추가함, 이때 부모 객체를 물려받아서 새로운 기능을 더한것(상속의 기본 사용법)
    component.render = function () {
      const result = `${this.name} - ${this.version} ` + this.mount() + '\n🐢 랜더링 완료!';
      document.getElementById('output1').textContent = result;
    };

    // ========================= 2. 안전한 해시맵 =========================
    // 완전히 비어 있는 객체를 생성함. 즉 toString, hasOwnProperty 같은 기본 속성도 없음
    const safeMap = Object.create(null);

    function addToSafeMap() {
      const key = document.getElementById('keyInput').value;
      const value = document.getElementById('valueInput').value;
      // 이게 진째 해시맵처럼 사용할 수 잇는 객체를 만드는 방법
      safeMap[key] = value;

      let result = '🔑 저장된 키 목록: \n';
      for (let k in safeMap) {
        result += `🔑 ${k} : ${safeMap[k]}\n`;
      }
      document.getElementById('output2').textContent = result;
    }

    // ========================= 3. 읽기 전용 설정 객체 =========================
    // 두 번째 인자로 속성 정의 객체를 전달함, writable이 false이기 때문에 appName을 바꿀 수 없음
    const config = Object.create(Object.prototype, {
      appName: {
        value: 'MySecureApp',
        writable: false,
        enumerable: true,
      },
    });

    document.getElementById('output3').textContent = `🔐 설정된 이름: ${config.appName}`;

    function tryToModify() {
      config.appName = document.getElementById('appName').value; // 변경 불가

      document.getElementById('text').textContent = `🔐 변경할 이름: ${document.getElementById('appName').value}`;
      document.getElementById('output3').textContent = `🔐 설정된 이름: ${config.appName} (변경 시도 무시됨)`;
    }
  </script>
</html>
