# JavaScript `this`와 객체지향

## `this`의 개념과 동작 원리

- `this`는 **함수를 호출한 주체(누가 호출했는지)**에 따라 참조하는 객체가 달라진다.
- 전역, 일반 함수, 메서드, 생성자, 화살표 함수, 이벤트 핸들러 등 호출 방식에 따라 값이 다르게 결정된다.
- `call`, `apply`, `bind`를 사용하면 `this`를 명시적으로 지정할 수 있다.
- 화살표 함수는 자신만의 `this`를 가지지 않고, 선언 시점의 상위 스코프 `this`를 사용한다.

## 자주 하는 실수와 해결 방법

- `setTimeout` 내부에서 일반 함수를 쓰면 `this`가 전역 객체를 가리킨다. → 화살표 함수 또는 `bind(this)`로 해결.
- 객체의 메서드를 변수에 담아 호출하면 원래 객체의 `this`가 사라진다. → `bind`를 사용해 `this`를 고정.

## 자바스크립트 객체지향

- JS는 프로토타입 기반 객체지향 언어.
- ES6 이후 class 문법이 도입되어 더 직관적으로 OOP 작성 가능하지만, 내부적으로는 여전히 프로토타입 상속.
- 주요 특징:
  1. 캡슐화: 속성과 메서드를 객체 안에 묶음
  2. 상속: 부모 객체의 기능을 자식 객체가 물려받음
  3. 다형성: 같은 메서드 이름이 상황에 따라 다르게 동작
- OOP에서 this는 현재 인스턴스를 가리키는 핵심 키워드이므로, 동작 원리 이해가 필수.

## 자바스크립트의 객체지향(OPP)

> 객체지향(Object-Oriented Programmin, OOP)은 데이터와 그 데이터를 조작하는 기능(메서드)을 하나로 객체로 묶어 재사용성과 유지보수성을 높이는 프로그래밍 패러다임

### JS 객체지향의 특징

1. 프로토타입 기반(Prototype-based)
   - JS는 전통적인 클래스 기반 언어와 달리, 모든 객체가 다른 객체를 상속받는 구조를 가진다.
   - 모든 객체는 내부적으로 `[[Prototype]]`을 가지고 있고, 이는 `__proto__`로 접근 가능하다.
2. 클래스 문법
   - ES6 이후 `class` 문법이 도입되어 문법적으로 클래스 기반처럼 작성 가능하지만, 내부적으로는 여전히 프로토타입 상속을 사용한다.
3. 동적 속성 추가 가능
   - 런타임에 객체에 속성이나 메서드를 자유롭게 추가/삭제 가능
4. 캡슐화, 상속, 다형성
   - 캡슐화: 객체 안에 데이터와 메서드를 묶음
   - 상속: 부모 객체(또는 클래스)의 기능을 자식이 물려받음
   - 다형성: 같은 메서드명이 상황(객체)에 따라 다르게 동작

```javascript
// 클래스 문법
class User {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`안녕, 나는 ${this.name}이야`);
  }
}

class Admin extends User {
  constructor(name, role) {
    super(name);
    this.role = role;
  }
  greet() {
    console.log(`[${this.role}] ${this.name}님, 환영합니다!`);
  }
}

const u1 = new User('시온');
u1.greet(); // "안녕, 나는 시온이야"

const admin = new Admin('관리자', '슈퍼관리자');
admin.greet(); // "[슈퍼관리자] 관리자님, 환영합니다!"
```

💡 `this`는 객체지향 프로그래밍에서 **"현재 인스턴스"**를 가리키는 중요한 키워드이기 때문에, OOP를 제대로 쓰려면 `this `동작 원리를 반드시 이해해야 함.

### 팀원들이 말하는 자바스크립트 객체지향

객체로 프로그래밍하면 된다.
그게 글래스이며, 이것만 알면 다 알고 있는 것.
추가로 클래스 객체 상속 부모 자식.
